/**
 * This class represents a container for storing various costs associated with
 * materials, including financial costs, CO2 usage, and waste generation.
 * It provides methods for adding, subtracting, and scaling costs.
 */
public class CostContainer {
    /**
     * Financial cost of the material.
     */
    private double cost;
    /**
     * CO2 usage associated with the material.
     */
    private double co2;
    /**
     * Amount of waste generated by the material.
     */
    private double waste;


    /**
     * Constructs a CostContainer with specified values for cost, CO2 usage, and waste.
     * This constructor demonstrates an object-oriented approach by initializing all
     * instance variables in a single step, encapsulating the data directly within
     * the object.
     *
     * @param cost  the financial cost of the material
     * @param co2   the CO2 usage associated with the material
     * @param waste the amount of waste generated
     */
    public CostContainer(double cost, double co2, double waste) {
        this.cost = cost;
        this.co2 = co2;
        this.waste = waste;
    }

    /**
     * Constructs a CostContainer with default values of zero for cost, CO2 usage, and waste.
     * This method follows a procedural approach by setting each variable individually.
     */
    public CostContainer(){
        this.cost = 0;
        this.co2 = 0;
        this.waste = 0;
    }

    /**
     * Adds the values of another CostContainer to this one and returns a new CostContainer
     * with the summed values.
     * This method exemplifies an object-oriented approach by operating on the internal
     * state of two CostContainer objects and creating a new object to hold the result.
     *
     * @param other the CostContainer to add to this one
     * @return a new CostContainer containing the summed values
     */
    public CostContainer addCostContainer(CostContainer other){
        CostContainer tmp = new CostContainer(cost, co2, waste);

        tmp.cost += other.getCost();
        tmp.co2 += other.getCo2();
        tmp.waste += other.getWaste();
        return tmp;
    }

    /**
     * Subtracts the values of another CostContainer from this one and returns a new CostContainer
     * with the resulting values.
     * This also demonstrates an object-oriented approach by manipulating objects directly and
     * encapsulating the result in a new instance.
     *
     * @param other the CostContainer to subtract from this one
     * @return a new CostContainer containing the resulting values after subtraction
     */
    public CostContainer subtractCostContainer(CostContainer other){
        CostContainer tmp = new CostContainer(cost, co2, waste);

        tmp.cost -= other.getCost();
        tmp.co2 -= other.getCo2();
        tmp.waste -= other.getWaste();
        return tmp;

    }

    /**
     * Multiplies each value in this CostContainer by a specified amount, returning a new
     * CostContainer with the scaled values.
     * The approach here is procedural in nature, as it sequentially multiplies each attribute
     * of the CostContainer by the specified factor, rather than involving additional object
     * manipulation or complex interactions.
     *
     * @param amount the multiplier for the costs
     * @return a new CostContainer with each value multiplied by the specified amount
     */
    public CostContainer multiplyContainer(double amount){
        CostContainer tmp = new CostContainer(cost, co2, waste);

        tmp.cost *= amount;
        tmp.co2 *= amount;
        tmp.waste *= amount;
        return tmp;

    }

    /**
     * Retrieves the financial, co2 and waste cost of the material.
     * Demonstrates encapsulation by providing controlled access to the private cost variable.
     *
     * @return the cost of the material
     */
    public double getCost(){
        return cost;
    }

    public double getCo2(){
        return co2;
    }

    public double getWaste(){
        return waste;
    }
}
