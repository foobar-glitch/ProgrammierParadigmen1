// keeps and updates state of a apartment in a building during the course of a simulation
// returns the current average happiness off all residents in the apartment
// as well as the costs incurred by maintaining/demolishing the apartment
// STYLE: nominal abstraction
// just by changing the names of the variable and classes used here
// this class might represent something completely different -> nominal
// (e.g. could easily be offices in an office building instead of apartments)
public class Apartment {

    /* Material used to build and renovate the apartment */
    private final MaterialBag constructionMaterial;
    /* Material currently in the Building */
    private MaterialBag material;
    /* Material which is currently wasted in the year */
    private MaterialBag wasteMaterial;
    /* Waste generated by construction work */
    private final CostContainer costs;
    /* Maximum Lifetime of the apartment, age and number of residents */
    private int lifetime, age, numberOfResidents;
    /* Definition of the intervall [factor, 0] in which Satisfaction
    is measured in getSatisfaction */
    private double satisfactionFactor = 1;

    public int getLifetime() {
        return lifetime;
    }

    /**
     * Apartment is immediately built automatically after creating the object.
     *
     * GOOD: Stores the state of the construction. Useful for upcoming iterations
     * and aging processes.
     *
     * Preconditions:
     * - constructionMaterial != null
     * - lifetime > 0
     * - numberOfResidents >= 0
     * - maxHappiness is a double in the range [1.0, MAX_DOUBLE]
     *
     * @param constructionMaterial Material used for construction (must not be null).
     * @param lifetime Lifetime of the building (must be > 0).
     * @param numberOfResidents Number of residents (must be >= 0).
     * @param maxHappiness Maximum happiness of inhabitants (must be in [1.0, MAX_DOUBLE]).
     */
    public Apartment(MaterialBag constructionMaterial, int lifetime, int numberOfResidents, double maxHappiness) {
        this.age = 0;
        this.lifetime = lifetime;
        this.numberOfResidents = numberOfResidents;
        this.constructionMaterial = constructionMaterial;
        this.material = constructionMaterial;
        this.costs = constructionMaterial.getTotalCost();
        this.wasteMaterial = new MaterialBag();
        this.satisfactionFactor = maxHappiness;
    }

    /**
     * Creates an Apartment from an Apartment.Record Object
     * @param record must not be null
     */
    public Apartment(Apartment.Record record){
        this.age = 0;
        this.lifetime = record.lifetimeApartment();
        this.numberOfResidents = record.residentNumber();
        this.constructionMaterial = record.material();
        this.material = record.material();
        this.costs = constructionMaterial.getTotalCost();
        this.wasteMaterial = new MaterialBag();
        this.satisfactionFactor = record.happinessUpperBound();
    }

    /**
     * Record of Apartment, which can be used to create an Apartment later on
     *
     * Preconditions:
     * - material != null
     * - lifetimeApartment > 0
     * - residentNumber >= 0
     * - happinessUpperBound is a double in the range [1.0, MAX_DOUBLE]
     * - numberOfApartments any number (parameter can be "ignored")
     *
     * @param material !=null
     * @param lifetimeApartment > 0, Lifetime of Building
     * @param residentNumber >= 0, Number of people living in the Building
     * @param happinessUpperBound ([1.0,n]) maximal Happiness of inhabitants
     * @param numberOfApartments (parameter can be ignored)
     */
    public record Record(MaterialBag material, int residentNumber, int numberOfApartments, int lifetimeApartment,
                         double happinessUpperBound) {

    }

    /**
     * Preconditions:
     * - current lifetime of Apartment < lifetime of Apartment
     *
     * Increments the Age (+1 year)
     * Calculates the cost created by the Building in one year and
     * adds it to temporary waste which can be retrieved by update()-method
     *
     * @return FALSE if the Apartment exceeded its lifetime
     */
    public boolean update() {
        age += 1;
        // Update Waste and new Current Construction Material
        MaterialBag waste = constructionMaterial.getWaste();
        wasteMaterial = wasteMaterial.add(
                waste
        );
        material = material.add(
                waste.times(-1)
        );
        // If no Material is there anymore :C (where's my house)
        if (constructionMaterial.size() == 0) return false;
        // If lifetime is exceeded return False
        return age <= lifetime;
    }

    /**
     * Calculates the yearly costs of the Apartment
     *
     * @return Cost of this Year
     */
    public CostContainer currentCost() {
        CostContainer costs = wasteMaterial.getTotalCost();
        wasteMaterial = new MaterialBag();
        return costs;
    }

    /**
     * Renovates the Apartment completely
     */
    public CostContainer renovate() {
        MaterialBag tmp = constructionMaterial.copy();
        tmp = tmp.add(material.times(-1));
        // Reset to Original Glory
        age = 0;
        material = constructionMaterial;

        satisfactionFactor *= 0.9;

        return tmp.getTotalCost().multiplyContainer(1.0 / numberOfResidents);
    }

    /**
     * Calculates Residents Satisfaction depending on
     * the state of their apartment
     *
     * @return Factor of residents' satisfaction
     */
    public double getSatisfaction() {
        double tmp = ((double) satisfactionFactor / Math.pow(lifetime, 2)) * (-Math.pow(age, 2)) + satisfactionFactor;
        return (double) tmp;
    }

    /**
     * Returns the number of Residents living in the apartment
     */
    public int getNumberOfResidents() {
        return numberOfResidents;
    }

    /**
     * Returns the total cost generated by the Apartment
     */
    public CostContainer getTotalCost() {
        return this.costs;
    }

    /**
     * Demolishes and Recycles Material of the Apartment and returns all costs
     * => Demolished Apartment
     * @param recycleRate ([0.0,1.0]) Rate of Apartments-Materials which can be recycled
     */
    public CostContainer demolish(double recycleRate) {
        // TODO: Change this line and add demolishing costs
        CostContainer leftoverMaterial = material.getTotalCost();
        CostContainer recycledProfit = new CostContainer(
                leftoverMaterial.getCost() * recycleRate,
                leftoverMaterial.getCo2() * recycleRate,
                leftoverMaterial.getWaste() * recycleRate
        );
        CostContainer tmp = material.getTotalCost();
        tmp = tmp.subtractCostContainer(recycledProfit);
        return tmp;
    }
}
